<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="待风而起" href="https://to-ywz.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="待风而起" href="https://to-ywz.github.io/atom.xml"><link rel="alternate" type="application/json" title="待风而起" href="https://to-ywz.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="操作系统,汇编,学习笔记,C"><link rel="canonical" href="https://to-ywz.github.io/CS/Book/DeepLeaningOS/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_3/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_3/"><title>深入理解计算机系统_3 - CS书籍笔记 | Black Sheep = 待风而起 = 以梦为马 驰骋世间</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">深入理解计算机系统_3</h1><div class="meta"><span class="item" title="创建时间：2021-02-23 18:38:45"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-02-23T18:38:45+08:00">2021-02-23</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>7.7k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>7 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Black Sheep</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva4.sinaimg.cn/large/005Q2GK3ly8gs3fdczyr9j30u010ttmj.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclize41wj20zk0m87gk.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclflwv2aj20zk0m84qp.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipevgoki5j20zk0m84qp.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giciukx8a7j20zk0m8aio.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipex2cdtbj20zk0m8x6p.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CS%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/" itemprop="item" rel="index" title="分类于 CS书籍笔记"><span itemprop="name">CS书籍笔记</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://to-ywz.github.io/CS/Book/DeepLeaningOS/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_3/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="秦殇"><meta itemprop="description" content="以梦为马 驰骋世间, 如风一般悠长"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="待风而起"></span><div class="body md" itemprop="articleBody"><h1 id="3-程序的机器表示"><a class="anchor" href="#3-程序的机器表示">#</a> 3 程序的机器表示</h1><h2 id="intel系列芯片发展历史"><a class="anchor" href="#intel系列芯片发展历史">#</a> Intel 系列芯片发展历史</h2><p>-- 该部分可略过</p><ul><li><strong>8086</strong> (1978)<br>它是第一代 16 位 微处理器之一.<br>8088 是 8086 的变种增加了一个 <strong>8 位的外部总线</strong> 可寻址地址空间仅有 20 位<br>8087 是 Intel 设计出的浮点协处理器，与 8086 或 8088 一同工作用于执行浮点指令，通常被称为 <code>x87</code></li><li><strong>80286</strong> (1982)<br>增加了更多的寻址模式 (已废弃), 构成了 IBM PC-AT 个人计算机的基础，是 MS Windows 最初使用的平台</li><li><strong>i386</strong> (1985)<br>将结构体系拓展到了 32 位。增加了平坦寻址模式， <code>Linux</code> 和 最近的 <code>Windows</code> 操作系统都采用了这种模式。这是 <code>Intel</code> 系列中第一台支持 <code>Unix</code> 操作系统的机器</li><li><strong>i486</strong> (1989)<br>改善了性能，同时将浮点单元集成到了处理器芯片，指令集上没有任何改变</li><li><strong>Pentium</strong> (1993)<br>改善了性能，不过只对指令集进行了小的扩展</li><li><strong>Pentium Pro</strong> (1995)<br>引入全新的全新的处理器设计，在内部被称为 P6 微体系结构.<br>指令集中增加了一类 &quot;条件传送 (conditional move)&quot; 指令</li><li><strong>Pentium/MMX</strong> (1997)<br>在 <code>Pentium</code> 处理器中增加了一类新的处理整数向量的指令。每个数据大小可以是 1,2 或 4 个字节。每个向量总长 64 字节</li><li><strong>Pentium II</strong> (1997)<br>P6 微体系结构的延伸</li><li><strong>Pentium III</strong> (1999)<br>引入 SSE, 是一类处理整数或浮点数向量的指令.<br>每个数据可以是 1, 2 或 4 字节，打包成 128 位的向量.<br>芯片上集成了二级高级缓存</li><li><strong>Pentium 4</strong> (2000)<br>SSE 扩展到了 SSE2, 增加了新的数据类型 (包括双精度浮点), 以及针对这种格式的数据的 114 条指令，编译器可以使用这些指令来编译浮点代码 (可替代 x87)</li><li><strong>Pentium 4E</strong> (2004)<br>增加了超线程 (hyperthreading), 使得一个处理器上可以同时运行两个程序<br>增加了 EM64T, 它是 <code>Intel</code> 对 <code>AMD</code> 提出的 <code>IA32</code> 的 64 位扩展的实现，被称为 <code>x86-64</code></li><li><strong>Core 2</strong> (2006)<br>回归到了 P6 的微体系结构. <code>Intel</code> 的第一个多核微处理器，不支持超线程</li><li><strong>Core i7 Nehalem</strong> (2008)<br>支持超线程，也有多核，最初的版本支持每个核上可以执行两个程序</li><li><strong>Core i7 Sandy Bridge</strong><br>引入了 <code>AVX</code> , 这是对 <code>SSE</code> 的拓展，支持把数据封装 256 位的向量</li><li><strong>Core i7 Haswell</strong><br>将 AVX 扩展至 <code>AVX2</code> , 增加了更多的指令和格式</li></ul><h2 id="程序编码"><a class="anchor" href="#程序编码">#</a> 程序编码</h2><p>C 语言到可执行文件需要经历四步:</p><pre><code>1.  预处理
    代码拓展,将所有 宏和头文件 加入源代码
2.  编译
    生成 .c 文件的 .s 文件
3.  汇编
    将 .s 文件生成 .o(二进制目标代码文件) 文件
4.  链接
    将 .o 文件按一定格式连接在一起 生成一个 CPU 可执行的文件
</code></pre><h3 id="机器代码"><a class="anchor" href="#机器代码">#</a> 机器代码</h3><blockquote><ul><li>ISA: 指令集架构<br>它定义了 处理器状态，指令集格式 及每条指令执行完毕之后对状<br>态的影响</li><li>虚拟地址：机器程序使用的地址</li></ul></blockquote><h3 id="代码示例"><a class="anchor" href="#代码示例">#</a> 代码示例</h3><blockquote><p>相关代码文件都在 3_2 文件夹中</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">long</span> <span class="token function">mult2</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">multstore</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span> <span class="token keyword">long</span> y<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token operator">*</span>dest<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">long</span> t <span class="token operator">=</span> <span class="token function">mult2</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token operator">*</span>dest <span class="token operator">=</span> t<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>执行命令 <code>gcc -Og -S mstore.c</code> 可以 得到 mstore.s<br>执行命令 <code>gcc -Og -c mstore.s</code> 可以 得到 mstore.o<br>执行命令 <code>objdump -d mstore.o</code> 可以 得到 mstore.o 的反汇编<br>(在 3_2 内 makefile 文件内有相关指令)</p></blockquote><h2 id="数据格式"><a class="anchor" href="#数据格式">#</a> 数据格式</h2><table><thead><tr><th>C 声明</th><th>Intel 数据类型</th><th>汇编代码后缀</th><th>大小 (字节)</th></tr></thead><tbody><tr><td>char</td><td>字节</td><td>b</td><td>1</td></tr><tr><td>short</td><td>节</td><td>w</td><td>2</td></tr><tr><td>int</td><td>双字</td><td>l</td><td>4</td></tr><tr><td>long</td><td>四字</td><td>q</td><td>8</td></tr><tr><td>char*</td><td>四字</td><td>q</td><td>8</td></tr><tr><td>float</td><td>单精度</td><td>s</td><td>4</td></tr><tr><td>double</td><td>双精度</td><td>l</td><td>8</td></tr></tbody></table><p>汇编使用后缀 <code>l</code> 来表示 <code>int</code> 和 <code>k'l</code> 并不冲突二者采用不同的指令和寄存器</p><h2 id="访问信息"><a class="anchor" href="#访问信息">#</a> 访问信息</h2><p>一个 x86-64 的包含 16 个存储 64 位值的 通用数据寄存器，如下表<br>所有寄存器以 <code>%r</code> 开头.<br>从 <code>%ax</code> - <code>%sp</code> 是 8086 时期的 寄存器<br>从 <code>%eax</code> - <code>%esp</code> 是 IA32 时引入的<br>从 <code>%r8</code> - <code>%r15</code> 是 x86-64 引入的<br><strong>对于寄存器操作：对于寄存器操作生成小于 8 字节的操作有以下规定 1-2 字节保持不变，生成 4 字节会将高位置 0</strong></p><table><thead><tr><th>64</th><th>32</th><th>16</th><th>8</th><th>作用</th></tr></thead><tbody><tr><td>%rax</td><td>%eax</td><td>%ax</td><td>%al</td><td>返回值</td></tr><tr><td>%rbx</td><td>%ebx</td><td>%bx</td><td>%bl</td><td>被调用者保存</td></tr><tr><td>%rcx</td><td>%ecx</td><td>%cx</td><td>%cl</td><td>第四个参数</td></tr><tr><td>%rdx</td><td>%edx</td><td>%dx</td><td>%dl</td><td>第三个参数</td></tr><tr><td>%rsi</td><td>%esi</td><td>%si</td><td>%sil</td><td>第二个参数</td></tr><tr><td>%rdi</td><td>%edi</td><td>%di</td><td>dil%</td><td>第一个参数</td></tr><tr><td>%rbp</td><td>%ebp</td><td>%bp</td><td>%bpl</td><td>被调用者保存</td></tr><tr><td>%rsp</td><td>%esp</td><td>%sp</td><td>%spl</td><td>栈指针</td></tr><tr><td>%r8</td><td>%r8d</td><td>%r8w</td><td>%r8b</td><td>第五个参数</td></tr><tr><td>%r9</td><td>%r9d</td><td>%r9w</td><td>%r9b</td><td>第六个参数</td></tr><tr><td>%r10</td><td>%r10d</td><td>%r10w</td><td>%r10b</td><td>调用者保存</td></tr><tr><td>%r11</td><td>%r11d</td><td>%r11w</td><td>%r11b</td><td>调用者保存</td></tr><tr><td>%r12</td><td>%r12d</td><td>%r12w</td><td>%r12b</td><td>被调用者保存</td></tr><tr><td>%r13</td><td>%r13d</td><td>%r13w</td><td>%r13b</td><td>被调用者保存</td></tr><tr><td>%r14</td><td>%r14d</td><td>%r14w</td><td>%r14b</td><td>被调用者保存</td></tr><tr><td>%r15</td><td>%r15d</td><td>%r15w</td><td>%r15b</td><td>被调用者保存</td></tr></tbody></table><h3 id="操作数指示符"><a class="anchor" href="#操作数指示符">#</a> 操作数指示符</h3><p>汇编指令大多数都有一个或多个操作符，一般来说操作符可以分为三种</p><blockquote><ol><li>立即数</li><li>寄存器</li><li>内存引用</li></ol></blockquote><p><img data-src="https://tva2.sinaimg.cn/large/005Q2GK3ly8gs1kzns6tlj31q90u0hdu.jpg" alt="alt 操作数格式"><br><strong>PS: 基址 和 变址 都必须是 64 位的寄存器</strong></p><h3 id="数据传输指令"><a class="anchor" href="#数据传输指令">#</a> 数据传输指令</h3><h3 id="基本数据传送指令"><a class="anchor" href="#基本数据传送指令">#</a> 基本数据传送指令</h3><hr><table><thead><tr><th>指令</th><th>效果</th><th>描述</th></tr></thead><tbody><tr><td>MOV S, D</td><td>D &lt;- S</td><td>传送</td></tr><tr><td colspan="2">movb</td><td>传送字节</td></tr><tr><td colspan="2">movw</td><td>传送节</td></tr><tr><td colspan="2">movl</td><td>传送双节</td></tr><tr><td colspan="2">movq</td><td>传送四节</td></tr><tr><td colspan="2">movb I, R</td><td>传送绝对的四节</td></tr></tbody></table><h3 id="扩展传送指令"><a class="anchor" href="#扩展传送指令">#</a> 扩展传送指令</h3><table><thead><tr><th>指令</th><th>效果</th><th>描述</th></tr></thead><tbody><tr><td>MOVZ</td><td>R &lt;- 零扩展 (s)</td><td>以 0 进行扩展传送</td></tr><tr><td colspan="2">movzbw</td><td>将做了 0 扩展的字节传送到字</td></tr><tr><td colspan="2">movzbl</td><td>将做了 0 扩展的字节传送到双字</td></tr><tr><td colspan="2">movzwl</td><td>将做了 0 扩展的字传送的双字</td></tr><tr><td colspan="2">movzbq</td><td>将做了 0 扩展的字节传送到四字</td></tr><tr><td colspan="2">movzwq</td><td>将做了 0 扩展的字传送到四字</td></tr></tbody></table><h3 id="符号扩展传送指令"><a class="anchor" href="#符号扩展传送指令">#</a> 符号扩展传送指令</h3><table><thead><tr><th>指令</th><th>效果</th><th>描述</th></tr></thead><tbody><tr><td>MOVS</td><td>R &lt;- 符号扩展 (s)</td><td>传送符号扩展字节</td></tr><tr><td colspan="2">movsbw</td><td>将做了 符号 扩展的字节传送到字</td></tr><tr><td colspan="2">movsbl</td><td>将做了 符号 扩展的字节传送到双字</td></tr><tr><td colspan="2">movswl</td><td>将做了 符号 扩展的字传送的双字</td></tr><tr><td colspan="2">movsbq</td><td>将做了 符号 扩展的字节传送到四字</td></tr><tr><td colspan="2">movswq</td><td>将做了 符号 扩展的字传送到四字</td></tr><tr><td colspan="2">cltq</td><td>把 <code>%eax</code> 符号 扩展到 <code>%rax</code></td></tr></tbody></table><h3 id="数据传送示例"><a class="anchor" href="#数据传送示例">#</a> 数据传送示例</h3><hr><p>交换两个数，不错的思路，减少一个 动态指针<br>C 代码位于 3_4_# 中，ASM 代码位于 3_4_3/ASM 中</p><blockquote><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">long</span> <span class="token function">exchange</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token operator">*</span>xp<span class="token punctuation">,</span> <span class="token keyword">long</span> y<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">long</span> x <span class="token operator">=</span> <span class="token operator">*</span>xp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token operator">*</span>xp <span class="token operator">=</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">return</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></blockquote><p>反汇编</p><blockquote><pre><code class="language-asm">0000000000000000 &lt;exchange&gt;:
  0:   8b 01                   mov    (%rcx),%eax
  2:   89 11                   mov    %edx,(%rcx)
  4:   c3                      retq
</code></pre></blockquote><h3 id="数据入栈和出栈"><a class="anchor" href="#数据入栈和出栈">#</a> 数据入栈和出栈</h3><hr><p>栈，数据类型的一种，FILO 只从顶部进出数据，只有两种操作 <code>pop</code> 和 <code>push</code></p><blockquote><table><thead><tr><th>指令</th><th>效果</th><th>描述</th></tr></thead><tbody><tr><td>pushq S</td><td>R[%rsp] &lt;- R[%rsp]-8;</td><td>将四字压入栈</td></tr><tr><td>M[ R[%rsp]] &lt;- S</td></tr><tr><td>popq S</td><td>D &lt;- M[ R[%rsp]];</td><td>将四字压入栈</td></tr><tr><td>R[%rsp] &lt;- R[%rsp]+8</td></tr></tbody></table><p><strong>PS: 由于与数据代码共用一片内存，栈空间也可以直接，寻址访问</strong></p></blockquote><h2 id="算数逻辑操作"><a class="anchor" href="#算数逻辑操作">#</a> 算数逻辑操作</h2><hr><p>操作符被分为四种</p><blockquote><ol><li>加载有效地址</li><li>一元操作符</li><li>二元操作符</li><li>移位<br>相关指令如下:</li></ol></blockquote><table><thead><tr><th>指令</th><th>效果</th><th>描述</th></tr></thead><tbody><tr><td>leaq S, D</td><td>D &lt;- &amp;S</td><td>加载有效地址</td></tr><tr></tr><tr><td>INC D</td><td>D &lt;- D+1</td><td>自加</td></tr><tr><td>DEC D</td><td>D &lt;- D-1</td><td>自减</td></tr><tr><td>NEG D</td><td>D &lt;- -D</td><td>取负</td></tr><tr><td>NOT D</td><td>D &lt;- ~D</td><td>取补</td></tr><tr></tr><tr><td>ADD S, D</td><td>D &lt;- D+S</td><td>加</td></tr><tr><td>SUB S, D</td><td>D &lt;- D-S</td><td>减</td></tr><tr><td>IMUL S, D</td><td>D &lt;- D*S</td><td>乘</td></tr><tr><td>XOR S, D</td><td>D &lt;- D^S</td><td>异或</td></tr><tr><td>AND S, D</td><td>D &lt;- D&amp;S</td><td>与</td></tr><tr><td>OR S, D</td><td>D &lt;- D</td><td>S</td><td>或</td></tr><tr></tr><tr><td>SAL k, D</td><td>D &lt;- D &lt;&lt; k</td><td>左移</td></tr><tr><td>SHL k, D</td><td>D &lt;- D &lt;&lt; k</td><td>左移 (等同于 SAL)</td></tr><tr><td>SAR k, D</td><td>D &lt;- D &gt;&gt; k</td><td>算数右移</td></tr><tr><td>SHR k, D</td><td>D &lt;- D &gt;&gt; k</td><td>逻辑右移</td></tr></tbody></table><h3 id="加载有效地址"><a class="anchor" href="#加载有效地址">#</a> 加载有效地址</h3><p><code>leaq</code> 命令用于传送有效地址，是 <code>mov</code> 指令的一个变种，类似于 C 语言中的 <code>&amp;</code> 的运算符。该指令和加载引用内存无关，一般用于简化 运算符.</p><table><thead><tr><th>指令</th><th>效果</th><th>描述</th></tr></thead><tbody><tr><td>leaq S, D</td><td>D &lt;- &amp;S</td><td>加载有效地址</td></tr></tbody></table><blockquote><p>例如:<br>设 <code>%rdx</code> 为 x , 那么 指令 <code>leaq 7(%rdx, %rdx, 4), %rax</code> 加载的 % <code>%rax</code> 寄存器最终的值为 <code>5x+7</code></p></blockquote><h3 id="一元和二元操作"><a class="anchor" href="#一元和二元操作">#</a> 一元和二元操作</h3><h3 id="一元操作"><a class="anchor" href="#一元操作">#</a> 一元操作</h3><blockquote><table><thead><tr><th>指令</th><th>效果</th><th>描述</th></tr></thead><tbody><tr><td>INC D</td><td>D &lt;- D+1</td><td>自加</td></tr><tr><td>DEC D</td><td>D &lt;- D-1</td><td>自减</td></tr><tr><td>NEG D</td><td>D &lt;- -D</td><td>取负</td></tr><tr><td>NOT D</td><td>D &lt;- ~D</td><td>取补</td></tr></tbody></table></blockquote><h3 id="二元操作"><a class="anchor" href="#二元操作">#</a> 二元操作</h3><blockquote><table><thead><tr><th>指令</th><th>效果</th><th>描述</th></tr></thead><tbody><tr><td>ADD S, D</td><td>D &lt;- D+S</td><td>加</td></tr><tr><td>SUB S, D</td><td>D &lt;- D-S</td><td>减</td></tr><tr><td>IMUL S, D</td><td>D &lt;- D*S</td><td>乘</td></tr><tr><td>XOR S, D</td><td>D &lt;- D^S</td><td>异或</td></tr><tr><td>AND S, D</td><td>D &lt;- D&amp;S</td><td>与</td></tr><tr><td>OR S, D</td><td>D &lt;- D</td><td>S</td><td>或</td></tr></tbody></table></blockquote><h3 id="移位操作"><a class="anchor" href="#移位操作">#</a> <a href="#%E7%9B%AE%E5%BD%95">移位操作</a></h3><p>移位量可以是一个 立即数，或者单字节寄存器 <code>%cl</code> 中。对于 x86-64 位移量取决于 <code>%cl</code> 的低 m 位决定的，2^m = w (w 为被操作数据的位数). 例如: <code>%rcl = 0xff</code> 时， <code>salb</code> 左移 7 位， <code>salw</code> 左移 15 位， <code>sall</code> 左移 31 位， <code>salq</code> 左移 63 位.</p><blockquote><table><thead><tr><th>指令</th><th>效果</th><th>描述</th></tr></thead><tbody><tr><td>SAL k, D</td><td>D &lt;- D &lt;&lt; k</td><td>左移</td></tr><tr><td>SHL k, D</td><td>D &lt;- D &lt;&lt; k</td><td>左移 (等同于 SAL)</td></tr><tr><td>SAR k, D</td><td>D &lt;- D &gt;&gt; k</td><td>算数右移</td></tr><tr><td>SHR k, D</td><td>D &lt;- D &gt;&gt; k</td><td>逻辑右移</td></tr></tbody></table></blockquote><p><strong>PS: 移位操作的目的操作数可以是寄存器 也可以是内存地址</strong></p><h3 id="分析"><a class="anchor" href="#分析">#</a> 分析</h3><p>相关文件位于 3_5_4 中，不知道什么原因，数据 参数 1 和参数 2 寄存器不可用<br><strong>大多数运算都是不区分符号，除了右移这个分为两种</strong></p><h3 id="特殊算数操作"><a class="anchor" href="#特殊算数操作">#</a> 特殊算数操作</h3><p>对于两个 64 位的数据运算 x86-64 提供了一定的支持，8 字数据，指令如下<br><img data-src="https://tva1.sinaimg.cn/large/005Q2GK3ly8gs1l0qd6frj323k0u0x6p.jpg" alt="alt 64位乘法"></p><ul><li>对于 64 位乘法，只有一个操作数，但是和 8086 类似 有一个 数据需要存放到 <code>%rax</code> , 得到的结果 分为高低位分别存放在 <code>%rdx</code> 和 <code>%rax</code> 中</li><li>对于除法 提供了单独的 <code>idivl</code> 被除数分为高低 64 位分别存放在 <code>%rdx</code> 和 <code>%rax</code> 寄存器中，得到的结果 商存放在 <code>%rax</code> , 余数存放在 <code>%rdx</code> . 除数由操作数给出，使用这个指令时，如果被除数是 64 位，需要将 <code>%rdx</code> 置 0 或者填充 符号位，可直接使用 <code>cqto</code></li><li>ps: <code>cqto</code> 不需要操作数，可以隐含的读出 <code>%rax</code> 的符号位，并填充到 <code>%rdx</code> 中</li></ul><h2 id="控制"><a class="anchor" href="#控制">#</a> 控制</h2><p>机器代码提供两种基本的基地机制来实现有条件的行为：测试数据值，然后根据测试结果来改变 <strong>控制流</strong> 或 <strong>数据流</strong>，一般来说流控制最为常用</p><h3 id="条件码"><a class="anchor" href="#条件码">#</a> 条件码</h3><table><thead><tr><th>条件码</th><th>作用</th></tr></thead><tbody><tr><td>CF</td><td>进位标志。最近的操作使最高位产生了进位。可以用于检查无符号的溢出</td></tr><tr><td>ZF</td><td>零标志。最近操作得出结果为 0</td></tr><tr><td>SF</td><td>符号标志。最近操作得到的结果为负数</td></tr><tr><td>OF</td><td>溢出标志。最近的操作导致一个补码溢出 -- 正溢出 / 负溢出</td></tr></tbody></table><ul><li><code>leaq</code> 指令 不会修改任何 条件码，</li><li><code>INC</code> 和 <code>DEC</code> 不会导致溢出码改变</li><li>CMP 和 TEST 指令不改变寄存器值只改变条件码，对应指令如图<br><img data-src="https://tva2.sinaimg.cn/large/005Q2GK3ly8gs1j1mqj47j30xv0u0jt4.jpg" alt="alt test 和 cmp 指令"></li></ul><h3 id="访问条件码"><a class="anchor" href="#访问条件码">#</a> 访问条件码</h3><p>条件码一般不会被直接读取，通常采用三种方式来使用:</p><ul><li>根据条件码的某种组合，将一个字节置 0/1</li><li>可以转跳到程序的某个其他部分</li><li>可以有条件的传送数据<br>与第一个使用 方法相关的指令为 <code>SET</code> , 用于对各种寄存器的高位清零。相关指令如图:<br><img data-src="https://tva2.sinaimg.cn/large/005Q2GK3ly8gs1i6k0ok7j31ax0u00x0.jpg" alt="alt set指令"><br><strong>PS: SET 只能操作字节</strong></li></ul><h3 id="跳转指令"><a class="anchor" href="#跳转指令">#</a> 跳转指令</h3><p><code>jmp</code> 指令可以进行无条件转跳，转跳分为两种</p><ul><li>直接转跳 <code>jmp 标号</code> ，例如 <code>jmp .L1</code></li><li>间接转跳 <code>jmp *%rax</code> , 例如 <code>jmp *%rax</code><br>如果需要将 寄存器的值 作为转跳地址这么写 <code>jmp *(%rax)</code><br><code>jump</code> 包括 了 <code>jmp</code> 和有条件转跳的 <code>jxx</code> , <code>jxx</code> 是有条件转跳 当条件码到一定时组合时，进行转跳。相关指令如下:<br><img data-src="https://tva1.sinaimg.cn/large/005Q2GK3ly8gs1i5rraf9j317a0u077x.jpg" alt="alt jump 指令"><br><strong>PS: 条件转跳只能进行直接转跳</strong></li></ul><h3 id="跳转指令的编码"><a class="anchor" href="#跳转指令的编码">#</a> 跳转指令的编码</h3><ul><li>编码分为两种，PC 指针 相对寻址 和 绝对地址</li><li>绝对地址 一般 为 1, 2, 4 字节中的 其中一个大小</li><li>大部分转跳都是使用 PC 指针相对转跳，即计算地址与 PC 指针 的差值</li><li>这部分的编码与链接息息相关<br>相关习题如下<br><img data-src="https://tva1.sinaimg.cn/large/005Q2GK3ly8gs1j0v6z7lj31dn0u07c0.jpg" alt="alt 必会习题"><br>指令 <code>rep</code> 和 <code>repz</code><br><img data-src="https://tva4.sinaimg.cn/large/005Q2GK3ly8gs1j1225lij32420u07i4.jpg" alt="alt rep和repz关系"></li></ul><h3 id="条件控制实现条件分支"><a class="anchor" href="#条件控制实现条件分支">#</a> 条件控制实现条件分支</h3><p>相关代码位于 3_6_5<br>调节表达式从 C 语言翻译为机器码最常用的方式为有条件转跳和无条件转跳相结合<br>C 语言 <code>if-else</code> 语句格式如下:</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>test_expr<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        then<span class="token operator">-</span>statement</pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">else</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">else</span><span class="token operator">-</span>statement</pre></td></tr></table></figure><p>对应的 <code>goto</code> 模拟板</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>t <span class="token operator">=</span> text_exper<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">goto</span> false<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    then<span class="token operator">-</span>statement</pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">goto</span> done<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>false<span class="token operator">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">else</span><span class="token operator">-</span>statement</pre></td></tr><tr><td data-num="8"></td><td><pre>done<span class="token operator">:</span></pre></td></tr></table></figure><h3 id="条件传送实现条件分支"><a class="anchor" href="#条件传送实现条件分支">#</a> 条件传送实现条件分支</h3><p>相关代码位于 3_6_6.<br>OPItem 为三目运算符编译结果<br>对于现代处理器 条件转移 (控制流) 十分低效。对于现代的 处理器 来说都采用 流水线 的方式 来提高性能，处理指令需要一系列的指令。当 处理器 遇到 条件指令时就会采用 极其精密的 分支预测逻辑 来猜测执行率，，只要比较可靠，流水线就会开始填充目前指令。但是预测出错就会导致 工作性能严重下降.<br>相比之下 条件传送 (控制数据) 只有在赋值 的情况下需要 进行判断，生成的汇编代码更加紧凑，执行的效率会更加高效.<br>其 C 语言格式如下:</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>v <span class="token operator">=</span> then_expr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>ve <span class="token operator">=</span> else_expr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>t <span class="token operator">=</span> test_exper</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">)</span> v <span class="token operator">=</span> ve<span class="token punctuation">;</span></pre></td></tr></table></figure><p>在汇编中通过 <code>comv</code> 指令来实现值传送<br>于其相关的指令如下<br><img data-src="https://tva1.sinaimg.cn/large/005Q2GK3ly8gs1i5tn4rqj31950u0ae4.jpg" alt="alt comv指令"><br><strong>PS: 条件传送不一定必然高效，而且存在 bug</strong><br>当 传入的值为指针时，不进行检测直接进行运算是十分危险的，而且在需要复杂计算时，采用条件传送会过于浪费时间，条件传送有很多局限性，但其的确最适合 现代处理器的执行方式</p><h3 id="循环"><a class="anchor" href="#循环">#</a> <a href="#%E7%9B%AE%E5%BD%95">循环</a></h3><h3 id="do-while-循环"><a class="anchor" href="#do-while-循环">#</a> do while 循环</h3><p>相关文件位于 3_6_7.1 中<br>其 等价 <code>goto</code> 代码 如下</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>loop<span class="token operator">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    body_statement</pre></td></tr><tr><td data-num="3"></td><td><pre>    t <span class="token operator">=</span> text_exper<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">goto</span> loop<span class="token punctuation">;</span></pre></td></tr></table></figure><p>逆向工程的核心就是确哪个寄存器对应的程序哪个值</p><hr><h3 id="while-循环"><a class="anchor" href="#while-循环">#</a> while 循环</h3><p>相关文件位于 3_6_7.2 中</p><ul><li>while 可能一次循环都不执行</li><li>GCC 采用两种方式来翻译 while, 两种翻译方式只有 初始检测方式不同，循环结构与 <code>do while</code> 无异<ol><li>转跳到中间 (jump to middle), 一开始会执行一个无条件转跳，跳到循环末尾处的测试，来实现初始检测</li></ol><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">goto</span> test<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>loop<span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    body_statement</pre></td></tr><tr><td data-num="4"></td><td><pre>test<span class="token operator">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    t <span class="token operator">=</span> text_exper<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">goto</span> loop<span class="token punctuation">;</span></pre></td></tr></table></figure><ol start="2"><li>guraded_do, 最开始使用条件分支，初始条件不成立即跳过循环，将代码转换为 <code>do while</code> 格式，使用 <code>-O1</code> 选项的时候，代码会使用这种方式进行编译</li></ol><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>翻译成 <span class="token keyword">do</span> <span class="token keyword">while</span></pre></td></tr><tr><td data-num="2"></td><td><pre>t <span class="token operator">=</span> text_exper<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">goto</span> done<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">do</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    body_statement<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    t <span class="token operator">=</span> test_exper<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">goto</span> loop<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>done<span class="token operator">:</span></pre></td></tr></table></figure><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>对应的 `<span class="token keyword">goto</span>` 版本</pre></td></tr><tr><td data-num="2"></td><td><pre>t <span class="token operator">=</span> text_exper<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">goto</span> done<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>loop<span class="token operator">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    body_statement<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    t <span class="token operator">=</span> test_exper<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">goto</span> loop<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>done<span class="token operator">:</span></pre></td></tr></table></figure><strong>PS : 采用第二种方式进行翻译时，有些时候 初始判断 会被优化</strong><br>个人感觉 后面这种翻译方式更加高效</li></ul><hr><h3 id="for-循环"><a class="anchor" href="#for-循环">#</a> for 循环</h3><p>相关文件位于 3_6_7.3 中<br>一般来说 for 循环结构如下</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span>init_exper<span class="token punctuation">;</span> text_exper<span class="token punctuation">;</span> update_exper<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    body_statement</pre></td></tr></table></figure><p>在 GCC 中 <code>for</code> 语句 会被转化为 两种 <code>while</code> 语句中的一种 格式大致如下，部分情况会进行微调<br>jump to middle 版本:</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>init_exper<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">goto</span> test<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>loop<span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    body_statement</pre></td></tr><tr><td data-num="5"></td><td><pre>    update_exper<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>test<span class="token operator">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    t <span class="token operator">=</span> text_exper<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">goto</span> loop<span class="token punctuation">;</span></pre></td></tr></table></figure><p>guraded_do 版本:</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>init_exper<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    t <span class="token operator">=</span> text_exper<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">goto</span> done<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>loop<span class="token operator">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    body_statement</pre></td></tr><tr><td data-num="7"></td><td><pre>    update_exper<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    t <span class="token operator">=</span> text_exper<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">goto</span> loop<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>done<span class="token operator">:</span></pre></td></tr></table></figure><h3 id="switch-语句"><a class="anchor" href="#switch-语句">#</a> switch 语句</h3><p>相关文件位于 3_6_8 中，TEST 中为测试 case 生成转跳表所用的文件</p><ul><li><code>switch</code> 语句在条件较多的情况下 (一般多余 4 个), 并且 case 值跨度较小的时候会更加高效，在翻译的时候会被翻译成 <strong>转跳表</strong></li><li><code>switch</code> 执行开关语句的时间与开关数量无关</li><li><code>&amp;&amp;</code> 运算符可以用来指向 代码地址，可以与 <code>goto</code> 搭配使用实现 <code>switch case</code></li><li><code>.rodata</code> 表示只读数据， <code>align 4</code> 表示 每个数据大小为 4 字 (8 字节)<br><img data-src="https://tva2.sinaimg.cn/large/005Q2GK3ly8gs1i6l3caoj30a501ea9v.jpg" alt="alt 书本样例">，<br>不过现在编译出来有些不同<br><img data-src="https://tva3.sinaimg.cn/large/005Q2GK3ly8gs1irtbxruj308b01b3yb.jpg" alt="alt 书本样例编译"></li></ul><h2 id="过程"><a class="anchor" href="#过程">#</a> <a href="#%E7%9B%AE%E5%BD%95">过程</a></h2><hr><p>过程是一种封装代码的方式，用一组指定的参数 和 可选返回值实现某种功能<br>实现这种功能的需要以下机器级支持一项或几项:</p><ul><li>传递控制</li><li>传递数据</li><li>分配和释放内存<br>为了简化讨论，我们把调用函数的过程称为 <code>P</code> , 被调用的函数称为 <code>fun</code></li></ul><h3 id="运行时栈"><a class="anchor" href="#运行时栈">#</a> 运行时栈</h3><p>这里的栈并非抽象概念，是一个实例. C 语言的过程调用就依赖于栈的 FILO 的机制.<br>如果 <code>P</code> 调用 <code>fun</code> , 那么流程大致如下:</p><ol><li><code>P</code> 被挂起， <code>P</code> 的数据存入栈中，进行现场保存.</li><li>为 <code>fun</code> 的数据 分配空间.</li><li><code>fun</code> 返回后，释放 <code>fun</code> 的数据空间</li><li>重新读入 <code>P</code> 数据，恢复现场<br>通用的栈结构:<br><img data-src="https://tva2.sinaimg.cn/large/005Q2GK3ly8gs1im431w9j30u01g8ttz.jpg" alt="alt 栈"></li></ol><p>有关 <code>P</code> 的数据只存放在 <code>P</code> 帧内部，返回地址一般会存放在整个帧的最末尾。一次调用最多传送 6 个整数值 (即 6 个 指针或整型), 其他类型或多出的参数会被存放栈帧里。参数构造一般会在调用前执行</p><h3 id="转移控制"><a class="anchor" href="#转移控制">#</a> 转移控制</h3><p>相关的指令如下:</p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>call Label</td><td>调用过程</td></tr><tr><td>call *Operand</td><td>过程调用</td></tr><tr><td>ret</td><td>从过程中返回</td></tr></tbody></table><p><code>P</code> 调用 <code>fun</code> 时，PC 计数器 被置为 <code>fun</code> 的首地址，返回后 PC 计数器 还原到原来的地址.<br>图示:<br><img data-src="https://tva2.sinaimg.cn/large/005Q2GK3ly8gs1i66tjl1j31xm0oeh3j.jpg" alt="alt call"></p><h3 id="数据传送"><a class="anchor" href="#数据传送">#</a> 数据传送</h3><p>上面说过，寄存器只有 6 个 是用来保存参数的，那么如果需要传参 &gt; 6 的参数，就需要预先存入栈中.<br>来看一个例子，分析以下多余的参数是如何在栈中分布的<br><img data-src="https://tva3.sinaimg.cn/large/005Q2GK3ly8gs1iriu5ttj30zv0u04fi.jpg" alt="alt param"><br>图片中 <code>a4p</code> 和 <code>a4</code> 转移到 <code>%rax</code> 和 <code>%edx</code> 数据来源于 <code>16(%rsp)</code> 和 <code>8(%rsp)</code> , 所以 多出的参数以 <code>push</code> 操作的正常大小压入栈内，以此类推<br>所以考虑将使用频率高的参数 提前.<br>结构体尽可能不要传值，在这也能体现出来，如果不想改变结构体的值，考虑传入一个 <code>const *</code> 指针</p><h3 id="栈上局部缓存"><a class="anchor" href="#栈上局部缓存">#</a> 栈上局部缓存</h3><p>这里就开始讨论， <code>fun</code> 数据存储的问题了.<br>目前出现的例子中没有超出寄存器大小的本地存储区域，但是以下这几种情况就需要将局部数据存入内存中:</p><ol><li>寄存器不足以存放所有本地数据</li><li>对一个局部变量使用 <code>&amp;</code> , 必须有相应的内存地址给其引用</li><li>局部变量是结构体或数组.</li></ol><p>来看一个例子:<br><img data-src="https://tva1.sinaimg.cn/large/005Q2GK3ly8gs1i6owwmrj30u00x3aj4.jpg" alt="alt swap_c"><br><img data-src="https://tva4.sinaimg.cn/large/005Q2GK3ly8gs1ir346dej31jb0u0h2e.jpg" alt="alt swap_s"><br><img data-src="https://tva3.sinaimg.cn/large/005Q2GK3ly8gs1i5xea9ij31qd0qmjy5.jpg" alt="alt caller_c"><br><img data-src="https://tva2.sinaimg.cn/large/005Q2GK3ly8gs1i6hixy6j30u010s7ny.jpg" alt="alt caller_s"></p><h3 id="寄存器中的局部存储空间"><a class="anchor" href="#寄存器中的局部存储空间">#</a> 寄存器中的局部存储空间</h3><p>在整个程序执行过程中 只有寄存器是被所有过程共享资源的，所以我们需要时刻注意，在调用其他过程的时候，寄存器的值不被覆盖，或者说如何保存调用前寄存器内部的值<br>依据惯例:</p><ul><li><code>%rbx</code> 、 <code>%bpx</code> 和 <code>%r12~%r15</code> 被划分为 <strong>被调用者保存寄存器</strong></li><li>除 <code>%rsp</code> 以及上面的寄存器 以外的寄存器，都被 称为<strong>调用者保存寄存器</strong></li></ul><p>来看一个例子:<br><img data-src="https://tva1.sinaimg.cn/large/005Q2GK3ly8gs1izlmj0jj30vn0u0dv6.jpg" alt="alt register"></p><h3 id="递归过程"><a class="anchor" href="#递归过程">#</a> 递归过程</h3><h2 id="数组分配"><a class="anchor" href="#数组分配">#</a> <a href="#%E7%9B%AE%E5%BD%95">数组分配</a></h2><hr><h3 id="基本原则"><a class="anchor" href="#基本原则">#</a> 基本原则</h3><h3 id="指针运算"><a class="anchor" href="#指针运算">#</a> 指针运算</h3><h3 id="嵌套数组"><a class="anchor" href="#嵌套数组">#</a> 嵌套数组</h3><h3 id="定长数组"><a class="anchor" href="#定长数组">#</a> 定长数组</h3><h3 id="变长数组"><a class="anchor" href="#变长数组">#</a> 变长数组</h3><h2 id="数据结构"><a class="anchor" href="#数据结构">#</a> <a href="#%E7%9B%AE%E5%BD%95">数据结构</a></h2><hr><h3 id="结构"><a class="anchor" href="#结构">#</a> 结构</h3><h3 id="联合"><a class="anchor" href="#联合">#</a> 联合</h3><h3 id="数据对齐"><a class="anchor" href="#数据对齐">#</a> 数据对齐</h3><h2 id="机器级程序中将控制与数据结合"><a class="anchor" href="#机器级程序中将控制与数据结合">#</a> <a href="#%E7%9B%AE%E5%BD%95">机器级程序中将控制与数据结合</a></h2><hr><h3 id="理解指针"><a class="anchor" href="#理解指针">#</a> 理解指针</h3><h3 id="应用-使用-gdb-调试器"><a class="anchor" href="#应用-使用-gdb-调试器">#</a> 应用：使用 GDB 调试器</h3><h3 id="对抗缓冲化攻击"><a class="anchor" href="#对抗缓冲化攻击">#</a> 对抗缓冲化攻击</h3><h2 id="浮点代码"><a class="anchor" href="#浮点代码">#</a> <a href="#%E7%9B%AE%E5%BD%95">浮点代码</a></h2><hr><h3 id="浮点传送和转换"><a class="anchor" href="#浮点传送和转换">#</a> 浮点传送和转换</h3><h3 id="过程中的浮点代码"><a class="anchor" href="#过程中的浮点代码">#</a> 过程中的浮点代码</h3><h3 id="浮点运算操作"><a class="anchor" href="#浮点运算操作">#</a> 浮点运算操作</h3><h3 id="定义和使用浮点"><a class="anchor" href="#定义和使用浮点">#</a> 定义和使用浮点</h3><h3 id="浮点代码中使用位级操作"><a class="anchor" href="#浮点代码中使用位级操作">#</a> 浮点代码中使用位级操作</h3><h3 id="浮点比较操作"><a class="anchor" href="#浮点比较操作">#</a> 浮点比较操作</h3><h3 id="结论"><a class="anchor" href="#结论">#</a> 结论</h3><h2 id="小结"><a class="anchor" href="#小结">#</a> <a href="#%E7%9B%AE%E5%BD%95">小结</a></h2><hr><div class="tags"><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%B1%87%E7%BC%96-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-C/" rel="tag"><i class="ic i-tag"></i> 操作系统,汇编,学习笔记,C</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2021-07-02 09:01:09" itemprop="dateModified" datetime="2021-07-02T09:01:09+08:00">2021-07-02</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="秦殇 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.jpg" alt="秦殇 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>秦殇 <i class="ic i-at"><em>@</em></i>待风而起</li><li class="link"><strong>本文链接：</strong> <a href="https://to-ywz.github.io/CS/Book/DeepLeaningOS/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_3/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_3/" title="深入理解计算机系统_3">https://to-ywz.github.io/CS/Book/DeepLeaningOS/深入理解计算机系统_3/深入理解计算机系统_3/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/CS/Embedded/%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8B%E4%B8%B2%E5%8F%A3%E7%A7%BB%E6%A4%8D%E4%B9%B1%E7%A0%81/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipexj2jgzj20zk0m8b09.jpg" title="标准库下串口移植乱码"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> STM32</span><h3>标准库下串口移植乱码</h3></a></div><div class="item right"><a href="/CS/Algorithm/Leetcode/P1%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/P1%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclhpw3lwj20zk0m8gvw.jpg" title="P1两数之和"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> LeetCode</span><h3>P1两数之和</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.</span> <span class="toc-text">3 程序的机器表示</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#intel%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2"><span class="toc-number">1.1.</span> <span class="toc-text">Intel 系列芯片发展历史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A0%81"><span class="toc-number">1.2.</span> <span class="toc-text">程序编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81"><span class="toc-number">1.2.1.</span> <span class="toc-text">机器代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">数据格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%A1%E6%81%AF"><span class="toc-number">1.4.</span> <span class="toc-text">访问信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="toc-number">1.4.1.</span> <span class="toc-text">操作数指示符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%8C%87%E4%BB%A4"><span class="toc-number">1.4.2.</span> <span class="toc-text">数据传输指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="toc-number">1.4.3.</span> <span class="toc-text">基本数据传送指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="toc-number">1.4.4.</span> <span class="toc-text">扩展传送指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E6%89%A9%E5%B1%95%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="toc-number">1.4.5.</span> <span class="toc-text">符号扩展传送指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.4.6.</span> <span class="toc-text">数据传送示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%85%A5%E6%A0%88%E5%92%8C%E5%87%BA%E6%A0%88"><span class="toc-number">1.4.7.</span> <span class="toc-text">数据入栈和出栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.</span> <span class="toc-text">算数逻辑操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%9C%89%E6%95%88%E5%9C%B0%E5%9D%80"><span class="toc-number">1.5.1.</span> <span class="toc-text">加载有效地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E5%92%8C%E4%BA%8C%E5%85%83%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.2.</span> <span class="toc-text">一元和二元操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.3.</span> <span class="toc-text">一元操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%85%83%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.4.</span> <span class="toc-text">二元操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.5.</span> <span class="toc-text">移位操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">1.5.6.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%AE%97%E6%95%B0%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.7.</span> <span class="toc-text">特殊算数操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6"><span class="toc-number">1.6.</span> <span class="toc-text">控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%A0%81"><span class="toc-number">1.6.1.</span> <span class="toc-text">条件码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%A1%E4%BB%B6%E7%A0%81"><span class="toc-number">1.6.2.</span> <span class="toc-text">访问条件码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="toc-number">1.6.3.</span> <span class="toc-text">跳转指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4%E7%9A%84%E7%BC%96%E7%A0%81"><span class="toc-number">1.6.4.</span> <span class="toc-text">跳转指令的编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF"><span class="toc-number">1.6.5.</span> <span class="toc-text">条件控制实现条件分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E4%BC%A0%E9%80%81%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF"><span class="toc-number">1.6.6.</span> <span class="toc-text">条件传送实现条件分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.6.7.</span> <span class="toc-text">循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#do-while-%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.6.8.</span> <span class="toc-text">do while 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#while-%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.6.9.</span> <span class="toc-text">while 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.6.10.</span> <span class="toc-text">for 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch-%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.6.11.</span> <span class="toc-text">switch 语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B"><span class="toc-number">1.7.</span> <span class="toc-text">过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88"><span class="toc-number">1.7.1.</span> <span class="toc-text">运行时栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E6%8E%A7%E5%88%B6"><span class="toc-number">1.7.2.</span> <span class="toc-text">转移控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81"><span class="toc-number">1.7.3.</span> <span class="toc-text">数据传送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E4%B8%8A%E5%B1%80%E9%83%A8%E7%BC%93%E5%AD%98"><span class="toc-number">1.7.4.</span> <span class="toc-text">栈上局部缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">1.7.5.</span> <span class="toc-text">寄存器中的局部存储空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B"><span class="toc-number">1.7.6.</span> <span class="toc-text">递归过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%88%86%E9%85%8D"><span class="toc-number">1.8.</span> <span class="toc-text">数组分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-number">1.8.1.</span> <span class="toc-text">基本原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97"><span class="toc-number">1.8.2.</span> <span class="toc-text">指针运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E6%95%B0%E7%BB%84"><span class="toc-number">1.8.3.</span> <span class="toc-text">嵌套数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E9%95%BF%E6%95%B0%E7%BB%84"><span class="toc-number">1.8.4.</span> <span class="toc-text">定长数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84"><span class="toc-number">1.8.5.</span> <span class="toc-text">变长数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.9.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-number">1.9.1.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88"><span class="toc-number">1.9.2.</span> <span class="toc-text">联合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90"><span class="toc-number">1.9.3.</span> <span class="toc-text">数据对齐</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E7%BA%A7%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%B0%86%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E5%90%88"><span class="toc-number">1.10.</span> <span class="toc-text">机器级程序中将控制与数据结合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E6%8C%87%E9%92%88"><span class="toc-number">1.10.1.</span> <span class="toc-text">理解指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-%E4%BD%BF%E7%94%A8-gdb-%E8%B0%83%E8%AF%95%E5%99%A8"><span class="toc-number">1.10.2.</span> <span class="toc-text">应用：使用 GDB 调试器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%8A%97%E7%BC%93%E5%86%B2%E5%8C%96%E6%94%BB%E5%87%BB"><span class="toc-number">1.10.3.</span> <span class="toc-text">对抗缓冲化攻击</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E4%BB%A3%E7%A0%81"><span class="toc-number">1.11.</span> <span class="toc-text">浮点代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E4%BC%A0%E9%80%81%E5%92%8C%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.11.1.</span> <span class="toc-text">浮点传送和转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E4%BB%A3%E7%A0%81"><span class="toc-number">1.11.2.</span> <span class="toc-text">过程中的浮点代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97%E6%93%8D%E4%BD%9C"><span class="toc-number">1.11.3.</span> <span class="toc-text">浮点运算操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8%E6%B5%AE%E7%82%B9"><span class="toc-number">1.11.4.</span> <span class="toc-text">定义和使用浮点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BD%8D%E7%BA%A7%E6%93%8D%E4%BD%9C"><span class="toc-number">1.11.5.</span> <span class="toc-text">浮点代码中使用位级操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C"><span class="toc-number">1.11.6.</span> <span class="toc-text">浮点比较操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">1.11.7.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.12.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/CS/Book/DeepLeaningOS/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_3/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_3/" rel="bookmark" title="深入理解计算机系统_3">深入理解计算机系统_3</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="秦殇" data-src="/images/avatar.png"><p class="name" itemprop="name">秦殇</p><div class="description" itemprop="description">如风一般悠长</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">30</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">11</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RvLXl3eg==" title="https:&#x2F;&#x2F;github.com&#x2F;to-ywz"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS8wbHJmOGY5R2hOT2dQakk=" title="https:&#x2F;&#x2F;twitter.com&#x2F;0lrf8f9GhNOgPjI"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9xaW4tc2hhbmctOTctNA==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;qin-shang-97-4"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTM5ODIwNTQyMTQ=" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;3982054214"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20vNTM0OTY3NDU5MQ==" title="https:&#x2F;&#x2F;weibo.com&#x2F;5349674591"><i class="ic i-weibo"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS9ibGFja3NoZWVwLjIwOGg=" title="https:&#x2F;&#x2F;about.me&#x2F;blacksheep.208h"><i class="ic i-address-card"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmJsYWNrc2hlZXAuMjA4aEBnbWFpbC5jb20=" title="mailto:blacksheep.208h@gmail.com"><i class="ic i-envelope"></i></span> <span class="exturl item facebook" data-url="aHR0cHM6Ly93d3cuZmFjZWJvb2suY29tL2xvdmVoeGxseHk=" title="https:&#x2F;&#x2F;www.facebook.com&#x2F;lovehxllxy"><i class="ic i-facebook"></i></span> <span class="exturl item stackoverflow" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9ibGFja3NoZWVw" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;blacksheep"><i class="ic i-stack-overflow"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/CS/Embedded/%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8B%E4%B8%B2%E5%8F%A3%E7%A7%BB%E6%A4%8D%E4%B9%B1%E7%A0%81/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/CS/Algorithm/Leetcode/P1%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/P1%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/mysql/" title="分类于 mysql">mysql</a></div><span><a href="/CS/Databases/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%94%E7%94%A8-Ubuntu%E4%B8%8BMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2/" title="数据库应用:Ubuntu下MySQL数据库简单查询">数据库应用:Ubuntu下MySQL数据库简单查询</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Algorithm/" title="分类于 Algorithm">Algorithm</a> <i class="ic i-angle-right"></i> <a href="/categories/Algorithm/leetcode/" title="分类于 LeetCode">LeetCode</a></div><span><a href="/CS/Algorithm/Leetcode/P7%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/P7%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/" title="P7整数反转">P7整数反转</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/CS/Embedded/STM32/%E6%96%B0%E5%BB%BAHAL%E5%BA%93%E5%B7%A5%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95/" title="新建HAL库工程的方法">新建HAL库工程的方法</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/blog/prism%E4%B8%8B%E7%89%B9%E6%9C%89%E6%B8%B2%E6%9F%93/" title="prism下特有渲染">prism下特有渲染</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/study-note/" title="分类于 学习笔记">学习笔记</a></div><span><a href="/CS/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E7%AC%94%E8%AE%B0/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E7%AC%94%E8%AE%B0/" title="C语言指针笔记">C语言指针笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Algorithm/" title="分类于 Algorithm">Algorithm</a> <i class="ic i-angle-right"></i> <a href="/categories/Algorithm/leetcode/" title="分类于 LeetCode">LeetCode</a></div><span><a href="/CS/Algorithm/Leetcode/P13%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/P13%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/" title="P13罗马数字转整数">P13罗马数字转整数</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/mysql/" title="分类于 mysql">mysql</a></div><span><a href="/CS/Databases/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%94%E7%94%A8-Ubuntu%E4%B8%8BMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" title="数据库应用:Ubuntu下MySQL数据库和数据表的基本操作">数据库应用:Ubuntu下MySQL数据库和数据表的基本操作</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Algorithm/" title="分类于 Algorithm">Algorithm</a> <i class="ic i-angle-right"></i> <a href="/categories/Algorithm/leetcode/" title="分类于 LeetCode">LeetCode</a></div><span><a href="/CS/Algorithm/Leetcode/P38%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/" title="P38外观数列">P38外观数列</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/" title="分类于 嵌入式">嵌入式</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/study-note/" title="分类于 学习笔记">学习笔记</a></div><span><a href="/CS/Embedded/%E7%A1%AC%E4%BB%B6%E5%A4%A7%E5%85%A8_%E9%9F%A6%E4%B8%9C%E5%B1%B1/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90/" title="嵌入式概念及硬件组成">嵌入式概念及硬件组成</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CS%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/" title="分类于 CS书籍笔记">CS书籍笔记</a></div><span><a href="/CS/Book/DeepLeaningOS/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_3/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_3/" title="深入理解计算机系统_3">深入理解计算机系统_3</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="ic i-BlackSheep"></i> </span><span class="author" itemprop="copyrightHolder">秦殇 @ Black Sheep</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">94k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">1:26</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"CS/Book/DeepLeaningOS/深入理解计算机系统_3/深入理解计算机系统_3/",favicon:{show:"ヾ(≧▽≦*)o",hide:"(｡･∀･)ﾉﾞ嗨"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:{placeholder:"1. 提问前请先仔细阅读本文档⚡\n2. 页面显示问题💥，请提供控制台截图📸或者您的测试网址\n3. 其他任何报错💣，请提供详细描述和截图📸，祝食用愉快(๑•̀ㅂ•́)و✧"},fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>